package Multithreading;import jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode;import org.checkerframework.checker.units.qual.C;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.Vector;import java.util.concurrent.*;/** * @author Chris Yang * created 2022-05-14 21:43 **/public class CountDownLatch_ {    public static void main(String[] args) {        CountDownLatch countDownLatch;    }}// 使用CountDownLatch来使线程等待class CountDownLatchDemo {    // 前置任务的并行    static public class PreTask implements Runnable {        private String task;        private CountDownLatch countDownLatch;        // 任务名字和前置任务数量参数的传递        public PreTask(String task, CountDownLatch countDownLatch) {            this.task = task;            this.countDownLatch = countDownLatch;        }        @Override        public void run() {            try {                Random random = new Random();                Thread.sleep(random.nextInt(1000));                System.out.println(task + " - 任务完成");                countDownLatch.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        CountDownLatch countDownLatch = new CountDownLatch(3);        new Thread(() -> {            try {                System.out.println("任务加载中");                System.out.println(String.format("还有%d个前置任务", countDownLatch.getCount()));                // 开启线程等待前置任务的完成                countDownLatch.await();                System.out.println("数据加载完成，开始游戏");            } catch (InterruptedException e) {                e.printStackTrace();            }        }).start();        new Thread(new PreTask("加载地图", countDownLatch)).start();        new Thread(new PreTask("加载任务", countDownLatch)).start();        new Thread(new PreTask("加载背景", countDownLatch)).start();    }}// 前置任务并行处理，使用线程池，减少创建线程的消耗class CountDownLatchDemo1 {    // 已下单订单    private static List<String> P_pool;    // 已派送订单    private static List<String> D_pool;    // 待派送订单    private static List<String> Dis_pool;    static int getPOrdersSize() {        return getP_pool().size();    }    static int getDOrdersSize() {        return getD_pool().size();    }    static List<String> getP_pool() {        return new ArrayList<>(); // 返回已下单订单，省略代码    }    static List<String> getD_pool() {        return new ArrayList<>(); // 返回派送订单，省略代码    }    // 查看还有哪些没有派送    static List<String> check(List<String> list1, List<String> list2) {        List<String> list = list1;        list.retainAll(list2);        return list;    }    // 记录今日的任务打印    static String save(List<String> list) {        StringBuilder sb = new StringBuilder();        for (int i = 0; i < list.size(); i++) {            sb.append(list.get(i) + "\t");        }        return sb.toString();    }    public static void main(String[] args) {        Executor executor = Executors.newFixedThreadPool(2);        CountDownLatch countDownLatch = new CountDownLatch(2);        // 使用线程池同时处理两个巨型订单的缓存读入        while (getPOrdersSize() != 0 || getDOrdersSize() != 0) {            executor.execute(() -> {                P_pool = getP_pool();                countDownLatch.countDown();            });            executor.execute(() -> {                D_pool = getD_pool();                countDownLatch.countDown();            });        }        // 如何实现两个线程读的互相等待，使用CountDownLatch 来对前置任务进行计数，执行完毕后才可进行下一步        // 使用CountDownLatch的await方法，等待所有前置任务的完成        try {            countDownLatch.await();        } catch (Exception e) {            e.printStackTrace();        }        Dis_pool = check(P_pool, D_pool);        save(Dis_pool);    }}// 再一次优化，两个订单获取和订单的比对也进行并行// T1 查询订单1// T2 查询订单2// T1，T2完成后，使用T3进行比较（下一轮的T1，T2开始）// 使用CyclicBarrier 来实现线程同步// T1,T2 的步调需要同步，这样每产生一条数据，就可以传递给T3进行核对class CyclicBarrierDemo1 extends CountDownLatchDemo1 {    static List<String> plist;    static List<String> dlist;    static List<String> check() {        return check(getD_pool(), getP_pool());    }    public void start() {        Executor executor = Executors.newFixedThreadPool(2);        final CyclicBarrier barrier = new CyclicBarrier(2, () -> {            executor.execute(() -> check());        });        Thread T1 = new Thread(() -> {            while (getDOrdersSize() != 0 || getPOrdersSize() != 0) {                plist = getP_pool();                try {                    barrier.await();                } catch (InterruptedException e) {                    throw new RuntimeException(e);                } catch (BrokenBarrierException e) {                    throw new RuntimeException(e);                }            }        });        T1.start();        Thread T2 = new Thread(() -> {            while (getDOrdersSize() != 0 || getPOrdersSize() != 0) {                dlist = getD_pool();                try {                    barrier.await();                } catch (InterruptedException e) {                    throw new RuntimeException(e);                } catch (BrokenBarrierException e) {                    throw new RuntimeException(e);                }            }        });        T2.start();    }    public static void main(String[] args) {    }}