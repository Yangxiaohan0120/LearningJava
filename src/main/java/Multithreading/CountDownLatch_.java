package Multithreading;import jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode;import org.checkerframework.checker.units.qual.C;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.Executor;import java.util.concurrent.Executors;/** * @author Chris Yang * created 2022-05-14 21:43 **/public class CountDownLatch_ {    public static void main(String[] args) {        CountDownLatch countDownLatch;    }}// 使用CountDownLatch来使线程等待class CountDownLatchDemo{    // 前置任务的并行    static public class PreTask implements Runnable{        private String task;        private CountDownLatch countDownLatch;        // 任务名字和前置任务数量参数的传递        public PreTask(String task, CountDownLatch countDownLatch){            this.task = task;            this.countDownLatch = countDownLatch;        }        @Override        public void run() {            try{                Random random = new Random();                Thread.sleep(random.nextInt(1000));                System.out.println(task + " - 任务完成");                countDownLatch.countDown();            }catch (InterruptedException e){                e.printStackTrace();            }        }    }    public static void main(String[] args) {        CountDownLatch countDownLatch = new CountDownLatch(3);        new Thread(() -> {            try{                System.out.println("任务加载中");                System.out.println(String.format("还有%d个前置任务",countDownLatch.getCount()));                // 开启线程等待前置任务的完成                countDownLatch.await();                System.out.println("数据加载完成，开始游戏");            }catch (InterruptedException e){                e.printStackTrace();            }        }).start();        new Thread(new PreTask("加载地图",countDownLatch)).start();        new Thread(new PreTask("加载任务",countDownLatch)).start();        new Thread(new PreTask("加载背景",countDownLatch)).start();    }}// 前置任务并行处理，使用线程池，减少创建线程的消耗class CountDownLatchDemo1{    // 已下单订单    private static List<String> P_pool;    // 已派送订单    private static List<String> D_pool;    // 待派送订单    private static List<String> Dis_pool;    static int getPOrdersSize(){        return getP_pool().size();    }    static int getDOrdersSize(){        return getP_pool().size();    }    static List<String> getP_pool(){        return new ArrayList<>(); // 返回已下单订单，省略代码    }    static List<String> getD_pool(){        return new ArrayList<>(); // 返回派送订单，省略代码    }    static List<String> check(List<String> list1, List<String> list2){        List<String> list = list1;        list.retainAll(list2);        return list;    }    static String save(List<String> list){        StringBuilder sb = new StringBuilder();        for (int i = 0; i < list.size(); i++) {            sb.append(list.get(i) +"\t");        }        return sb.toString();    }    public static void main(String[] args) {        Executor executor = Executors.newFixedThreadPool(2);        CountDownLatch countDownLatch = new CountDownLatch(2);        // 使用线程池同时处理两个巨型订单的缓存读入        while(getPOrdersSize() != 0 || getDOrdersSize() != 0){            executor.execute(() -> {                P_pool = getP_pool();                countDownLatch.countDown();            });            executor.execute(() ->{                D_pool = getD_pool();                countDownLatch.countDown();            });        }        // 如何实现两个线程读的互相等待，使用CountDownLatch 来对前置任务进行计数，执行完毕后才可进行下一步        // 使用CountDownLatch的await方法，等待所有前置任务的完成        try {            countDownLatch.await();        }catch (Exception e){            e.printStackTrace();        }        Dis_pool = check(P_pool,D_pool);        save(Dis_pool);    }}// 再一次优化，两个订单获取和订单的比对也进行并行// T1 查询订单1// T2 查询订单2// T1，T2完成后，使用T3进行比较// 使用CyclicBarrier 来实现线程同步class CountDownLatchDemo2 extends CountDownLatchDemo1{    static List<String> check(){        return check(getD_pool(),getP_pool());    }    public static void main(String[] args) {        Executor executor = Executors.newFixedThreadPool(2);        final CyclicBarrier barrier = new CyclicBarrier(2,() ->{            executor.execute(() -> check());        });        Thread T1 = new Thread(() ->{            while (getDOrdersSize() != 0 || getPOrdersSize() != 0){                getD_pool();                getP_pool();            }            try {                barrier.await();            }catch (Exception e){                e.printStackTrace();            }        });    }}